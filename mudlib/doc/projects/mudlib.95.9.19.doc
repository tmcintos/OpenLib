Here it is, this got longer than I expected it would....

1. Room.c
2. Commands
3. Login
4. Security
5. Attack System
6. Directory Setup of mudlib

-------
Room.c:
-------
  I wrote a bad version of this back in June, and Eric took it and fixed
it up and optimized it.  When telling the number of exits, it uses a nifty
function I've been working on to convert int_to_word(int i).  This is pretty
cool, I worked on it the other day so now it will return the word
representation for any integer from -999,999,999 to 999,999,999.

---------
Commands:
---------
  I've got quite a few of these in.  I ended up going with an include file
#include <cmdline.h> that provides a main() function that gets all the
flags and stuff out then calls _main() which you define.  I only use this
file for commands which actually need flags; other commands just define
a regular old main(string arg)...
  I've got an ed() interface in the player body that uses the new(er) mudlib
frontend ability for ed...
  Probably want to put in a command daemon that keeps a mapping or something
of commands and where they are located to speed things up.  I don't
particularly want to go the same way as Viking on this one though...

------
Login:
------
  I think I've finally got the login sequence close to what I want:  There
is a daemon LOGIN_D that remains loaded.  When connect() in the master is
called, it returns new(CONNECTION_OB) which is a small object that just
holds the name,password,login_time,real_name,from_ip,etc. and related
query_* and set_* functions.  logon() gets called in the CONNECTION_OB
which in turn calls LOGIN_D->logon(this_object()), which handles the login
sequence for all players (keeping track of them by their connection_ob's).
  LOGIN_D determines what body to load for each player from that player's
connection object, (string)conn_ob->query_body(), then exec()'s the player
into their body and destruct()'s the connection object for that player.
(note that their is only one body right now, user.c, which sucks :))
  Finger, passwd, and similar commands just do a temporary restore_object()
on the player's connection obj when they need to know or change something...

---------
Security:  (I'm going to need help on this.)
---------
  I'd like to be able to set up security using a combination of uid's and
groups if possible.  I have done a little work so right now the only way
any object can have a uid=ROOT_UID is to be loaded from the /adm directory
tree.  Objects loaded out of a domain directory have the uid=Domainname,
and objects loaded out of a wizard's directory have that wizard's uid.
Currently, all other objects have uid=System, which != BACKBONE_UID.
LOGIN_D sets player's uid=username.
  (this isn't in yet, but no object except _group_ root can seteuid() to
anything besides getuid() or 0.)

  I've set up a daemon for groups GROUP_D daemon
that reads group lists from a file under /adm.  It has functions such as
int is_member(string group, string uid) and group_exists(string group)
that can be used in security as well as other things.  (I'm using a group 
"all", that can be defined to be a certain group of users, to control
who is allowed to log into the MUD)

  My current plan is to check permissions by groups, determining group
membership by effective uid.

  I got an idea from Idea Exchange's Foundation II (nightmare) mudlib for
security;  they check to make sure all objects returned by call_stack()
have permission to do the action in question.  In cases where a player
would call a guild function or something that would need to write to a
wizard's home directory, they provide an efun unguarded(function f) that
executes function 'f' without checking the entire call stack for permission.

  Anyway, we're still going to have to put some thought into this.  I had
a valid_write() done, but it's messed up so I commented it out and put the
good ol' return 1; back in. :)

--------------
Attack System: (this is straight from the doc Eric gave me...)
--------------
  The combat system is operated from a daemon. This structure gives
us a couple of advantages over having the code in the living (player/monster)
body.  The first and perhaps foremost from the view of a mudlib coder is that
reboots are not needed for a minor change to the combat system (cheer).  From
the administartors view, this SHOULD be somewhat faster (yeah, right) because
nearly all information islocal and does not need to be called up from
forien objects.  It also allows us to enforce more structure to the
information.

  A brief listing of the functions in the daemon and what they do follows.
-----------------------------------------------------------------------------
Create()
 Nothing much.  Don't call this unless you happening to be loading the file
 as well. =P
clear_all_combat_info()
 Clears all the combat information.  non-formaly ceases all combat in progress.
query_dmg_message()
 Kept seperate for readability and some modularity.  Just returns a message
 that describes the ammount of damage provided.
clean_up_all_attackers()
 Housekeeping function called by continue_all_attacks().  May be later
 removed and installed directly into continue_all_attacks.  If two attackers
 are not next to each other, the stop fighting each other.
continue_all_attacks()
 This is the small lump of code that tells everybody to attack everybody else.
execute_attack(obj victim, attacker, mixed *weapon_info, hit_mod, dmg_mod)
 This is the nasy code that auctualy executes the attack.
 Call this to have person a swing at person b.  weapon info (so far) is
 partitioned as follows:

weapon_info[0]: int damage bonus
1: int damage range(0 to ??-1) use this to damage format to cut a few cpu ticks
2: int to_hit bonus
3: string *weapon_messages
4: string *hit_verbs (eg. slice, chop)
5: string *hit_verbs2 (eg. slices, chops)
6: string *miss_verbs (eg.slice above, swing wildly at, whatever)
7: string *miss_verbs2 (eg. slices above, swings wildly at, etc)
8: weapon_names (eg. longsword, spear, pike, etc...)
9:  bitmap (int) weapon_type(explaned elsewhere(?))
10: object weapon_object (whatever is being used to execute the attack.)
11: Non-crucial (just wield info) bitmap hands wielded with

execute_bow_attack(object victim, attacker, mixed weapon_info)
 Executes an attack with a bow if it is ready, else increments its readyness.
init_combat(forget it, do't call.  ok?)
 I won't explain this cause you AIN'T SUPPOSED TO CALL IT!
kill_ob(object attacker, victim)
 Starts the two fighting each other.  Returns 0 on success, !0 on failuer.
 (namely if it's an object, not present, attacking yourself, etc...)
-----------------------------------------------------------------------------
That concludes that part.  Mail me(casper) at(epeters@netcom.com) if you need
any more functions added.  namely all the good queries.  Don't forget:
I won't add it if you don't ask.

----------------
Directory Setup:
----------------

I changed this around the other day to make it more logical...
Current mudlib directory structure (9/19/95):

(adm==secure--only writeable by group root)
/adm________/cmd________/adm
       |           |____/player
       |           |____/wiz
       |____/efuns
       |____/etc
       |____/obj________/clone
       |           |____/daemon_________/net
       |           |____/inherit
       |
       |____/tmp

/cmd________/adm
       |____/player
       |____/wiz

/d__________/base

/data_______/binaries
       |____/user________/body___________/a->/z
                   |_____/connection_____/a->/z

/doc________/Copying
       |____/driver
       |____/man_________/man1
       |           |_____/man2
       |           |_____/man3
       |____/projects

/ftp

/include____/net
         |__/user

/log

/obj________/clone
       |____/daemon_______/net
       |____/inherit

/tmp

/u__________/a->/z
